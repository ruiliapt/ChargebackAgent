from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime, timedelta
import os
import json
import random
import time
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

app = Flask(__name__)
CORS(app)

# Database configuration
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///chargeback_agent.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Data models
class DisputeCase(db.Model):
    id = db.Column(db.String(50), primary_key=True)
    case_number = db.Column(db.String(20), unique=True, nullable=False)
    transaction_id = db.Column(db.String(50), nullable=False)
    customer_id = db.Column(db.String(50), nullable=False)
    amount = db.Column(db.Float, nullable=False)
    currency = db.Column(db.String(3), default='USD')
    merchant_name = db.Column(db.String(200), nullable=False)
    merchant_category = db.Column(db.String(100))
    transaction_date = db.Column(db.DateTime, nullable=False)
    location = db.Column(db.String(200))
    card_last4 = db.Column(db.String(4))
    dispute_reason = db.Column(db.String(200), nullable=False)
    dispute_description = db.Column(db.Text)
    risk_score = db.Column(db.Integer, default=0)
    ai_recommendation = db.Column(db.String(20))  # approve, reject, review
    ai_confidence = db.Column(db.Integer, default=0)
    ai_analysis = db.Column(db.Text)
    human_decision = db.Column(db.String(20))  # approve, reject
    status = db.Column(db.String(20), default='pending')  # pending, analyzing, review, completed
    priority = db.Column(db.String(20), default='medium')  # low, medium, high, critical
    category = db.Column(db.String(50))  # FRAUD_UNAUTHORIZED, PROCESSING_ISSUES, MERCHANT_MERCHANDISE
    subcategory = db.Column(db.String(50))  # 1A_Card_Fraud, 2B_Technical_Processing, etc.
    reason_code = db.Column(db.String(10))  # Visa/MC/Amex reason codes
    card_network = db.Column(db.String(20))  # visa, mastercard, amex
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow)
    
    # New transaction-related fields
    items = db.Column(db.String(200))
    digital_goods = db.Column(db.String(1))
    login_method = db.Column(db.String(50))
    item_shipped = db.Column(db.String(1))
    item_shipped_date = db.Column(db.DateTime)
    item_delivered = db.Column(db.String(1))
    item_delivered_date = db.Column(db.DateTime)
    same_card_success_orders = db.Column(db.Integer)
    same_address_success_orders = db.Column(db.Integer)
    same_ip_success_orders = db.Column(db.Integer)
    same_device_success_orders = db.Column(db.Integer)
    checkout_ip = db.Column(db.String(50))
    checkout_device = db.Column(db.String(100))
    card_issuer = db.Column(db.String(100))

class Customer(db.Model):
    id = db.Column(db.String(50), primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(200))
    phone = db.Column(db.String(20))
    account_type = db.Column(db.String(50))
    credit_score = db.Column(db.Integer)
    customer_since = db.Column(db.DateTime)
    previous_disputes = db.Column(db.Integer, default=0)
    
    # New customer analytics fields
    dispute_customer_won = db.Column(db.Integer)
    total_purchase_amount = db.Column(db.Float)
    dispute_percentage = db.Column(db.Float)
    linked_customers_count = db.Column(db.Integer)
    linked_customers_dispute_rate = db.Column(db.Float)
    linked_by_device = db.Column(db.Integer)
    linked_by_ip = db.Column(db.Integer)
    linked_by_card = db.Column(db.Integer)
    linked_by_address = db.Column(db.Integer)

# AI Analysis Engine
class ChargebackAnalysisEngine:
    def __init__(self):
        self.risk_factors = {
            'amount_weight': 0.10,                  # 10% - Transaction amount factor
            'customer_history_weight': 0.10,        # 10% - Customer history factor
            'merchant_risk_weight': 0.05,           # 5% - Merchant risk factor
            'dispute_reason_weight': 0.05,          # 5% - Dispute reason factor
            'evidence_weight': 0.10,                # 10% - Evidence completeness factor
            'transaction_legitimacy_weight': 0.40,  # 40% - Transaction legitimacy (PRIMARY FACTOR)
            'abuse_patterns_weight': 0.20           # 20% - Abuse patterns (SECONDARY FACTOR)
        }
    
    def calculate_risk_score(self, dispute_data, customer_data):
        """Calculate risk score with abusive chargeback detection"""
        score = 0
        
        # Transaction amount factor (15%)
        amount_score = self._calculate_amount_risk(dispute_data['amount'])
        score += amount_score * self.risk_factors['amount_weight']
        
        # Customer history factor (15%)
        customer_score = self._calculate_customer_risk(customer_data)
        score += customer_score * self.risk_factors['customer_history_weight']
        
        # Merchant risk factor (15%)
        merchant_score = self._calculate_merchant_risk(dispute_data['merchant_category'])
        score += merchant_score * self.risk_factors['merchant_risk_weight']
        
        # Dispute reason factor (10%)
        reason_score = self._calculate_reason_risk(dispute_data['dispute_reason'])
        score += reason_score * self.risk_factors['dispute_reason_weight']
        
        # Evidence completeness factor (15%)
        evidence_score = self._calculate_evidence_risk(dispute_data.get('evidence', []))
        score += evidence_score * self.risk_factors['evidence_weight']
        
        # NEW: Transaction legitimacy factor (15%) - legitimate customer patterns
        legitimacy_score = self._calculate_transaction_legitimacy(dispute_data)
        score += legitimacy_score * self.risk_factors['transaction_legitimacy_weight']
        
        # NEW: Abusive chargeback patterns factor (15%) - abusive behavior detection
        abuse_score = self._calculate_abuse_patterns(dispute_data, customer_data)
        score += abuse_score * self.risk_factors['abuse_patterns_weight']
        
        return min(100, max(0, int(score)))
    
    def _calculate_amount_risk(self, amount):
        """Calculate risk based on amount"""
        if amount < 100:
            return 10
        elif amount < 500:
            return 25
        elif amount < 2000:
            return 50
        else:
            return 80
    
    def _calculate_customer_risk(self, customer_data):
        """Calculate risk based on customer history"""
        score = 0
        
        # Credit score
        credit_score = customer_data.get('credit_score', 650)
        if credit_score > 750:
            score += 10
        elif credit_score > 650:
            score += 30
        else:
            score += 70
        
        # Historical dispute count
        previous_disputes = customer_data.get('previous_disputes', 0)
        score += min(30, previous_disputes * 10)
        
        return score
    
    def _calculate_merchant_risk(self, category):
        """Calculate risk based on merchant category"""
        high_risk_categories = ['Luxury Goods', 'Online Services', 'Travel Services']
        medium_risk_categories = ['Electronics', 'Subscription Service']
        
        if category in high_risk_categories:
            return 60
        elif category in medium_risk_categories:
            return 35
        else:
            return 20
    
    def _calculate_reason_risk(self, reason):
        """Calculate risk based on dispute reason"""
        high_risk_reasons = ['Fraudulent Transaction', 'Identity Theft']
        medium_risk_reasons = ['Unauthorized Transaction', 'Duplicate Charge']
        
        if reason in high_risk_reasons:
            return 80
        elif reason in medium_risk_reasons:
            return 50
        else:
            return 30
    
    def _calculate_evidence_risk(self, evidence):
        """Calculate risk based on evidence completeness"""
        if len(evidence) == 0:
            return 80
        elif len(evidence) == 1:
            return 50
        else:
            return 20
    
    def _calculate_transaction_legitimacy(self, dispute_data):
        """Calculate risk based on transaction legitimacy indicators
        CORRECTED LOGIC: Higher established patterns = Higher risk (abusive chargeback)
        If card/address/IP has successful history = cardholder made transaction = dispute is suspicious
        """
        legitimacy_score = 0
        
        # Same card success orders - ANY orders = HIGHLY SUSPICIOUS (cardholder disputing own transaction)
        same_card_orders = dispute_data.get('same_card_success_orders', 0)
        if same_card_orders >= 10:
            legitimacy_score += 95  # Extremely suspicious - definitely cardholder's transaction
        elif same_card_orders >= 5:
            legitimacy_score += 85  # Very suspicious - likely cardholder's transaction
        elif same_card_orders >= 1:
            legitimacy_score += 75  # HIGHLY suspicious - ANY same card usage indicates cardholder
        else:
            legitimacy_score += 5   # Could be actual fraud (stolen card)
        
        # Same shipping address success orders - ANY orders = HIGHLY SUSPICIOUS
        same_address_orders = dispute_data.get('same_address_success_orders', 0)
        if same_address_orders >= 5:
            legitimacy_score += 90  # Extremely suspicious - cardholder's familiar address
        elif same_address_orders >= 1:
            legitimacy_score += 80  # HIGHLY suspicious - ANY same address indicates cardholder
        else:
            legitimacy_score += 10  # New address - could be fraud
        
        # Same IP success orders - ANY orders = HIGHLY SUSPICIOUS
        same_ip_orders = dispute_data.get('same_ip_success_orders', 0)
        if same_ip_orders >= 5:
            legitimacy_score += 85  # Extremely suspicious - cardholder's regular IP
        elif same_ip_orders >= 1:
            legitimacy_score += 75  # HIGHLY suspicious - ANY same IP indicates cardholder
        else:
            legitimacy_score += 15  # New IP - could be fraud/VPN
        
        # Same device success orders - ANY orders = HIGHLY SUSPICIOUS
        same_device_orders = dispute_data.get('same_device_success_orders', 0)
        if same_device_orders >= 5:
            legitimacy_score += 90  # Extremely suspicious - cardholder's regular device
        elif same_device_orders >= 1:
            legitimacy_score += 80  # HIGHLY suspicious - ANY same device indicates cardholder
        else:
            legitimacy_score += 10  # New device - could be fraud
        
        # Item shipping status - successful delivery makes dispute more suspicious
        item_shipped = dispute_data.get('item_shipped', 'N')
        item_delivered = dispute_data.get('item_delivered', 'N')
        digital_goods = dispute_data.get('digital_goods', 'N')
        
        if digital_goods == 'Y':
            legitimacy_score += 25  # Digital goods - harder to verify delivery
        elif item_delivered == 'Y':
            legitimacy_score += 60  # VERY suspicious - item was delivered but disputing
        elif item_shipped == 'Y':
            legitimacy_score += 40  # Suspicious - item was shipped
        else:
            legitimacy_score += 10  # Not shipped - could be legitimate complaint
        
        # Average the legitimacy indicators (divide by 5 factors)
        return int(legitimacy_score / 5)
    
    def _calculate_abuse_patterns(self, dispute_data, customer_data):
        """Calculate risk based on abusive chargeback patterns
        Higher scores indicate more abusive behavior
        """
        abuse_score = 0
        
        # Customer dispute rate analysis
        dispute_percentage = customer_data.get('dispute_percentage', 0)
        if dispute_percentage >= 10:  # >10% dispute rate is very high
            abuse_score += 80
        elif dispute_percentage >= 5:  # 5-10% is high
            abuse_score += 60
        elif dispute_percentage >= 2:  # 2-5% is concerning
            abuse_score += 35
        elif dispute_percentage >= 1:  # 1-2% is elevated
            abuse_score += 20
        else:
            abuse_score += 5  # <1% is normal
        
        # Customer dispute win rate (customers who win too many disputes are suspicious)
        dispute_customer_won = customer_data.get('dispute_customer_won', 0)
        previous_disputes = customer_data.get('previous_disputes', 0)
        
        if previous_disputes > 0:
            win_rate = (dispute_customer_won / previous_disputes) * 100
            if win_rate >= 80:  # Winning >80% of disputes is suspicious
                abuse_score += 70
            elif win_rate >= 60:  # 60-80% win rate
                abuse_score += 45
            elif win_rate >= 40:  # 40-60% win rate
                abuse_score += 25
            else:
                abuse_score += 10  # <40% win rate is normal
        
        # Linked customers analysis (fraud rings)
        linked_customers_count = customer_data.get('linked_customers_count', 0)
        linked_customers_dispute_rate = customer_data.get('linked_customers_dispute_rate', 0)
        
        if linked_customers_count > 0:
            if linked_customers_dispute_rate >= 8:  # Linked customers with high dispute rate
                abuse_score += 60  # Likely fraud ring
            elif linked_customers_dispute_rate >= 4:
                abuse_score += 35  # Concerning network
            elif linked_customers_dispute_rate >= 2:
                abuse_score += 20  # Elevated network risk
            else:
                abuse_score += 5   # Normal linked customer activity
        
        # Multiple linking methods (suspicious if linked by many different methods)
        linked_by_device = customer_data.get('linked_by_device', 0)
        linked_by_ip = customer_data.get('linked_by_ip', 0)
        linked_by_card = customer_data.get('linked_by_card', 0)
        linked_by_address = customer_data.get('linked_by_address', 0)
        
        linking_methods = sum([1 for x in [linked_by_device, linked_by_ip, linked_by_card, linked_by_address] if x > 0])
        if linking_methods >= 4:  # Linked by all methods - very suspicious
            abuse_score += 50
        elif linking_methods >= 3:  # Linked by 3 methods
            abuse_score += 30
        elif linking_methods >= 2:  # Linked by 2 methods
            abuse_score += 15
        # 1 or 0 linking methods is normal
        
        # Total purchase amount vs dispute amount (frequent small disputes on large purchase history)
        total_purchase = customer_data.get('total_purchase_amount', 0)
        current_dispute_amount = dispute_data.get('amount', 0)
        
        if total_purchase > 0:
            dispute_ratio = (current_dispute_amount / total_purchase) * 100
            if dispute_ratio < 1 and previous_disputes > 5:  # Many small disputes relative to total spending
                abuse_score += 30  # Potential abuse pattern
        
        # Average the abuse indicators (divide by 5 main factors)
        return min(100, int(abuse_score / 5))
    
    def generate_recommendation(self, risk_score):
        """Generate AI recommendation with adjusted thresholds for new weight distribution"""
        if risk_score < 40:
            return 'approve', 85 + random.randint(0, 10)
        elif risk_score < 60:
            return 'review', 70 + random.randint(0, 15)
        else:
            return 'reject', 60 + random.randint(0, 20)
    
    def generate_analysis(self, dispute_data, customer_data, risk_score, recommendation):
        """Generate analysis report"""
        analysis_templates = {
            'approve': "After AI analysis, this dispute case has low risk. Customer has good credit record and reasonable dispute reason. Recommend approving refund.",
            'reject': "After AI analysis, this dispute case has high risk. Recommend further investigation or rejecting the refund request.",
            'review': "This case requires manual review. AI analysis found some risk factors. Recommend detailed investigation before making a decision."
        }
        
        base_analysis = analysis_templates.get(recommendation, "")
        
        # Add specific analysis details
        details = []
        if customer_data.get('credit_score', 0) > 700:
            details.append("Customer has excellent credit score")
        if customer_data.get('previous_disputes', 0) == 0:
            details.append("No historical dispute records")
        if dispute_data['amount'] > 2000:
            details.append("Large transaction requires special attention")
        
        if details:
            base_analysis += " Key factors include: " + ", ".join(details) + "."
        
        return base_analysis

# åˆå§‹åŒ–åˆ†æå¼•æ“
analysis_engine = ChargebackAnalysisEngine()

# APIè·¯ç”±
@app.route('/api/health', methods=['GET'])
def health_check():
    """å¥åº·æ£€æŸ¥"""
    return jsonify({'status': 'healthy', 'timestamp': datetime.utcnow().isoformat()})

@app.route('/api/disputes', methods=['GET'])
def get_disputes():
    """è·å–æ‰€æœ‰äº‰è®®æ¡ˆä¾‹"""
    disputes = DisputeCase.query.all()
    result = []
    
    for dispute in disputes:
        customer = Customer.query.get(dispute.customer_id)
        dispute_dict = {
            'id': dispute.id,
            'caseNumber': dispute.case_number,
            'transaction': {
                'id': dispute.transaction_id,
                'amount': dispute.amount,
                'currency': dispute.currency,
                'merchantName': dispute.merchant_name,
                'merchantCategory': dispute.merchant_category,
                'transactionDate': dispute.transaction_date.isoformat(),
                'location': dispute.location,
                'cardLast4': dispute.card_last4,
                # New transaction fields
                'items': dispute.items or 'N/A',
                'digitalGoods': dispute.digital_goods or 'N/A',
                'loginMethod': dispute.login_method or 'N/A',
                'itemShipped': dispute.item_shipped or 'N/A',
                'itemShippedDate': dispute.item_shipped_date.isoformat() if dispute.item_shipped_date else 'N/A',
                'itemDelivered': dispute.item_delivered or 'N/A',
                'itemDeliveredDate': dispute.item_delivered_date.isoformat() if dispute.item_delivered_date else 'N/A',
                'sameCardSuccessOrders': dispute.same_card_success_orders or 0,
                'sameAddressSuccessOrders': dispute.same_address_success_orders or 0,
                'sameIpSuccessOrders': dispute.same_ip_success_orders or 0,
                'sameDeviceSuccessOrders': dispute.same_device_success_orders or 0,
                'checkoutIp': dispute.checkout_ip or 'N/A',
                'checkoutDevice': dispute.checkout_device or 'N/A'
            },
            'customer': {
                'id': customer.id if customer else '',
                'name': customer.name if customer else '',
                'email': customer.email if customer else '',
                'phone': customer.phone if customer else '',
                'accountType': customer.account_type if customer else '',
                'creditScore': customer.credit_score if customer else 0,
                'customerSince': customer.customer_since.isoformat() if customer and customer.customer_since else '',
                'previousDisputes': customer.previous_disputes if customer else 0,
                # New customer fields
                'disputeCustomerWon': customer.dispute_customer_won or 0 if customer else 0,
                'totalPurchaseAmount': customer.total_purchase_amount or 0 if customer else 0,
                'disputePercentage': customer.dispute_percentage or 0 if customer else 0,
                'linkedCustomersCount': customer.linked_customers_count or 0 if customer else 0,
                'linkedCustomersDisputeRate': customer.linked_customers_dispute_rate or 0 if customer else 0,
                'linkedByDevice': customer.linked_by_device or 0 if customer else 0,
                'linkedByIp': customer.linked_by_ip or 0 if customer else 0,
                'linkedByCard': customer.linked_by_card or 0 if customer else 0,
                'linkedByAddress': customer.linked_by_address or 0 if customer else 0
            },
            'disputeReason': dispute.dispute_reason,
            'disputeDescription': dispute.dispute_description,
            'evidence': [],  # ç®€åŒ–å¤„ç†
            'riskScore': dispute.risk_score,
            'aiRecommendation': dispute.ai_recommendation,
            'aiConfidence': dispute.ai_confidence,
            'aiAnalysis': dispute.ai_analysis,
            'humanDecision': dispute.human_decision,
            'status': dispute.status,
            'createdAt': dispute.created_at.isoformat(),
            'updatedAt': dispute.updated_at.isoformat(),
            'priority': dispute.priority,
            'category': dispute.category,
            'subcategory': dispute.subcategory,
            'reasonCode': dispute.reason_code,
            'cardNetwork': dispute.card_network,
            'cardIssuer': dispute.card_issuer or 'N/A'
        }
        result.append(dispute_dict)
    
    return jsonify(result)

@app.route('/api/disputes/<dispute_id>/analyze', methods=['POST'])
def analyze_dispute(dispute_id):
    """åˆ†æç‰¹å®šäº‰è®®æ¡ˆä¾‹"""
    dispute = DisputeCase.query.get(dispute_id)
    if not dispute:
        return jsonify({'error': 'Dispute not found'}), 404
    
    customer = Customer.query.get(dispute.customer_id)
    
    # Simulate AI analysis process
    time.sleep(2)  # Simulate analysis delay
    
    # Build analysis data
    dispute_data = {
        'amount': dispute.amount,
        'merchant_category': dispute.merchant_category,
        'dispute_reason': dispute.dispute_reason,
        'evidence': []  # Simplified processing
    }
    
    customer_data = {
        'credit_score': customer.credit_score if customer else 650,
        'previous_disputes': customer.previous_disputes if customer else 0
    }
    
    # Calculate risk score
    risk_score = analysis_engine.calculate_risk_score(dispute_data, customer_data)
    
    # Generate recommendation
    recommendation, confidence = analysis_engine.generate_recommendation(risk_score)
    
    # Generate analysis report
    analysis = analysis_engine.generate_analysis(dispute_data, customer_data, risk_score, recommendation)
    
    # Update database
    dispute.risk_score = risk_score
    dispute.ai_recommendation = recommendation
    dispute.ai_confidence = confidence
    dispute.ai_analysis = analysis
    dispute.status = 'review' if recommendation == 'review' else 'analyzing'
    dispute.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    return jsonify({
        'riskScore': risk_score,
        'recommendation': recommendation,
        'confidence': confidence,
        'analysis': analysis,
        'keyFactors': _get_key_factors(dispute_data, customer_data),
        'warningFlags': _get_warning_flags(dispute_data, customer_data, risk_score)
    })

def _get_key_factors(dispute_data, customer_data):
    """Get supporting factors"""
    factors = []
    if customer_data.get('credit_score', 0) > 700:
        factors.append('Customer has excellent credit score')
    if customer_data.get('previous_disputes', 0) == 0:
        factors.append('No dispute history records')
    if dispute_data['amount'] < 500:
        factors.append('Dispute amount is small')
    return factors

def _get_warning_flags(dispute_data, customer_data, risk_score):
    """Get risk flags"""
    flags = []
    if customer_data.get('previous_disputes', 0) > 2:
        flags.append('Multiple dispute history')
    if risk_score > 70:
        flags.append('High risk score')
    if dispute_data['amount'] > 2000:
        flags.append('Large transaction amount')
    return flags

@app.route('/api/disputes/<dispute_id>/decision', methods=['POST'])
def make_decision(dispute_id):
    """åšå‡ºäººå·¥å†³ç­–"""
    data = request.json
    decision = data.get('decision')
    
    if decision not in ['approve', 'reject']:
        return jsonify({'error': 'Invalid decision'}), 400
    
    dispute = DisputeCase.query.get(dispute_id)
    if not dispute:
        return jsonify({'error': 'Dispute not found'}), 404
    
    dispute.human_decision = decision
    dispute.status = 'completed'
    dispute.updated_at = datetime.utcnow()
    
    db.session.commit()
    
    return jsonify({'message': 'Decision recorded successfully'})

@app.route('/api/chat', methods=['POST'])
def chat():
    """AI chat interface"""
    data = request.json
    message = data.get('message', '')
    
    # Simple chat response logic
    response = _generate_chat_response(message)
    
    return jsonify({
        'response': response,
        'timestamp': datetime.utcnow().isoformat()
    })

def _generate_chat_response(message):
    """Generate chat response"""
    message_lower = message.lower()
    
    if 'analyze' in message_lower or 'case' in message_lower:
        disputes = DisputeCase.query.filter_by(status='pending').limit(3).all()
        response = f"I found {len(disputes)} pending dispute cases."
        for dispute in disputes:
            response += f"\n\nğŸ“‹ Case {dispute.case_number}\nğŸ’° Amount: ${dispute.amount}\nğŸ¯ Risk Score: {dispute.risk_score}/100"
        return response
    
    if 'risk' in message_lower:
        high_risk_count = DisputeCase.query.filter(DisputeCase.risk_score > 70).count()
        return f"Currently there are {high_risk_count} high-risk cases requiring attention. High-risk cases typically include abnormal transaction amounts, multiple customer dispute history, and other characteristics."
    
    if 'help' in message_lower or 'function' in message_lower:
        return """I can provide the following assistance:

ğŸ” **Intelligent Analysis**: Automatically analyze risk levels of dispute cases
ğŸ“Š **Data Insights**: Provide dispute trend and pattern analysis  
ğŸ’¡ **Decision Recommendations**: Give processing suggestions based on AI algorithms
âš¡ **Quick Queries**: Rapidly find specific cases or statistical information
ğŸ“‹ **Workflow Guidance**: Guide you through standard processing procedures

You can ask me questions about specific cases or request analysis of the overall situation."""
    
    return "I understand your inquiry. I am a professional dispute analysis AI assistant that can help you analyze dispute cases, assess risks, and provide decision recommendations. How can I assist you?"

@app.route('/api/init-demo-data', methods=['POST'])
def init_demo_data():
    """åˆå§‹åŒ–æ¼”ç¤ºæ•°æ®"""
    # æ¸…é™¤ç°æœ‰æ•°æ®
    db.drop_all()
    db.create_all()
    
    # åˆ›å»ºæ¼”ç¤ºå®¢æˆ·
    customers = [
        Customer(id='cust_001', name='å¼ ä¼Ÿ', email='zhang.wei@email.com', phone='+1-555-0123',
                account_type='ç™½é‡‘å¡', credit_score=750, customer_since=datetime(2019, 3, 15), previous_disputes=1),
        Customer(id='cust_002', name='ææ˜', email='li.ming@email.com', phone='+1-555-0456',
                account_type='æ™®é€šå¡', credit_score=680, customer_since=datetime(2021, 7, 20), previous_disputes=0),
        Customer(id='cust_003', name='ç‹èŠ³', email='wang.fang@email.com', phone='+1-555-0789',
                account_type='é»‘é‡‘å¡', credit_score=820, customer_since=datetime(2015, 5, 10), previous_disputes=3),
        Customer(id='cust_004', name='é™ˆæ¶›', email='chen.tao@email.com', phone='+1-555-0321',
                account_type='æ™®é€šå¡', credit_score=720, customer_since=datetime(2020, 11, 5), previous_disputes=0),
        Customer(id='cust_005', name='åˆ˜æ´‹', email='liu.yang@email.com', phone='+1-555-0654',
                account_type='é‡‘å¡', credit_score=695, customer_since=datetime(2018, 9, 22), previous_disputes=2)
    ]
    
    for customer in customers:
        db.session.add(customer)
    
    # åˆ›å»ºæ¼”ç¤ºäº‰è®®æ¡ˆä¾‹
    disputes = [
        DisputeCase(
            id='1', case_number='CD2024001', transaction_id='txn_001', customer_id='cust_001',
            amount=1250.00, merchant_name='TechMart Online', merchant_category='ç”µå­äº§å“',
            transaction_date=datetime(2024, 1, 15, 10, 30), location='çº½çº¦, NY', card_last4='4567',
            dispute_reason='æœªæˆæƒäº¤æ˜“', dispute_description='å®¢æˆ·å£°ç§°æ²¡æœ‰è¿›è¡Œæ­¤ç¬”äº¤æ˜“ï¼Œå£°ç§°ä¿¡ç”¨å¡åœ¨å£°æ˜çš„æ—¶é—´ä¸åœ¨èº«è¾¹ã€‚',
            risk_score=45, ai_recommendation='review', ai_confidence=72,
            ai_analysis='è¯¥æ¡ˆä¾‹å­˜åœ¨ä¸­ç­‰é£é™©ã€‚å®¢æˆ·æä¾›äº†ä½ç½®è¯æ˜ï¼Œä½†äº¤æ˜“å‘ç”Ÿåœ¨å®¢æˆ·å±…ä½åœ°é™„è¿‘çš„å•†æˆ·ã€‚',
            status='pending', priority='medium'
        ),
        DisputeCase(
            id='2', case_number='CD2024002', transaction_id='txn_002', customer_id='cust_002',
            amount=89.99, merchant_name='QuickFood Delivery', merchant_category='é¤é¥®å¤–å–',
            transaction_date=datetime(2024, 1, 14, 19, 45), location='æ—§é‡‘å±±, CA', card_last4='8901',
            dispute_reason='å•†å“è´¨é‡é—®é¢˜', dispute_description='å®¢æˆ·æ”¶åˆ°çš„é£Ÿç‰©ä¸è®¢å•ä¸ç¬¦ï¼Œä¸”è´¨é‡å¾ˆå·®ã€‚',
            risk_score=25, ai_recommendation='approve', ai_confidence=88,
            ai_analysis='ä½é£é™©æ¡ˆä¾‹ã€‚å®¢æˆ·æä¾›äº†å……åˆ†çš„è¯æ®ï¼Œäº¤æ˜“é‡‘é¢è¾ƒå°ï¼Œå®¢æˆ·å†å²è®°å½•è‰¯å¥½ã€‚',
            status='pending', priority='low'
        ),
        DisputeCase(
            id='3', case_number='CD2024003', transaction_id='txn_003', customer_id='cust_003',
            amount=3500.00, merchant_name='Luxury Watches Co.', merchant_category='å¥¢ä¾ˆå“',
            transaction_date=datetime(2024, 1, 13, 14, 20), location='è¿ˆé˜¿å¯†, FL', card_last4='2345',
            dispute_reason='é‡å¤æ”¶è´¹', dispute_description='å®¢æˆ·å£°ç§°è¢«é‡å¤æ”¶è´¹ä¸¤æ¬¡è´­ä¹°åŒä¸€å—æ‰‹è¡¨ã€‚',
            risk_score=75, ai_recommendation='reject', ai_confidence=65,
            ai_analysis='é«˜é£é™©æ¡ˆä¾‹ã€‚è™½ç„¶å®¢æˆ·ä¿¡ç”¨è¯„åˆ†å¾ˆé«˜ï¼Œä½†æœ‰å¤šæ¬¡äº‰è®®å†å²ã€‚äº¤æ˜“é‡‘é¢è¾ƒå¤§ï¼Œéœ€è¦ä»”ç»†éªŒè¯ã€‚',
            status='analyzing', priority='high'
        ),
        DisputeCase(
            id='4', case_number='CD2024004', transaction_id='txn_004', customer_id='cust_004',
            amount=199.99, merchant_name='StreamingPlus', merchant_category='è®¢é˜…æœåŠ¡',
            transaction_date=datetime(2024, 1, 12, 0, 1), location='åœ¨çº¿', card_last4='6789',
            dispute_reason='å–æ¶ˆè®¢é˜…åä»è¢«æ”¶è´¹', dispute_description='å®¢æˆ·åœ¨2023å¹´12æœˆå–æ¶ˆäº†å¹´åº¦è®¢é˜…ï¼Œä½†ä»è¢«æ”¶å–2024å¹´çš„è´¹ç”¨ã€‚',
            risk_score=20, ai_recommendation='approve', ai_confidence=92,
            ai_analysis='ä½é£é™©æ¡ˆä¾‹ã€‚å®¢æˆ·æä¾›äº†æ˜ç¡®çš„å–æ¶ˆç¡®è®¤é‚®ä»¶ï¼Œä¸”å®¢æˆ·å†å²è®°å½•ä¼˜ç§€ã€‚',
            status='review', priority='low'
        ),
        DisputeCase(
            id='5', case_number='CD2024005', transaction_id='txn_005', customer_id='cust_005',
            amount=850.00, merchant_name='AirTravel Bookings', merchant_category='æ—…è¡ŒæœåŠ¡',
            transaction_date=datetime(2024, 1, 10, 16, 45), location='èŠåŠ å“¥, IL', card_last4='1234',
            dispute_reason='æœåŠ¡æœªæä¾›', dispute_description='ç”±äºèˆªç­å–æ¶ˆï¼Œå®¢æˆ·çš„æ—…è¡Œè¢«å–æ¶ˆã€‚å•†æˆ·æ‹’ç»é€€æ¬¾ã€‚',
            risk_score=55, ai_recommendation='review', ai_confidence=78,
            ai_analysis='ä¸­ç­‰é£é™©æ¡ˆä¾‹ã€‚å®¢æˆ·æœ‰åˆç†çš„é€€æ¬¾ç†ç”±ï¼Œä½†å•†æˆ·çš„æ¡æ¬¾å¯èƒ½ç¡®å®ä¸æ”¯æŒé€€æ¬¾ã€‚',
            status='pending', priority='medium'
        )
    ]
    
    for dispute in disputes:
        db.session.add(dispute)
    
    db.session.commit()
    
    return jsonify({'message': 'Demo data initialized successfully'})

# New category-based API endpoints
@app.route('/api/disputes/by-category/<category>', methods=['GET'])
def get_disputes_by_category(category):
    """Get disputes by main category (FRAUD_UNAUTHORIZED, PROCESSING_ISSUES, MERCHANT_MERCHANDISE)"""
    try:
        disputes = DisputeCase.query.filter_by(category=category).all()
        
        disputes_list = []
        for dispute in disputes:
            customer = Customer.query.get(dispute.customer_id)
            dispute_dict = {
                'id': dispute.id,
                'caseNumber': dispute.case_number,
                'category': dispute.category,
                'subcategory': dispute.subcategory,
                'reasonCode': dispute.reason_code,
                'cardNetwork': dispute.card_network,
                'transaction': {
                    'id': dispute.transaction_id,
                    'amount': dispute.amount,
                    'currency': dispute.currency,
                    'merchantName': dispute.merchant_name,
                    'merchantCategory': dispute.merchant_category,
                    'transactionDate': dispute.transaction_date.isoformat() if dispute.transaction_date else None,
                    'location': dispute.location,
                    'cardLast4': dispute.card_last4
                },
                'customer': {
                    'id': dispute.customer_id,
                    'name': customer.name if customer else 'Unknown',
                    'email': customer.email if customer else 'Unknown',
                    'phone': customer.phone if customer else 'Unknown',
                    'accountType': customer.account_type if customer else 'Unknown',
                    'creditScore': customer.credit_score if customer else 0,
                    'customerSince': customer.customer_since.isoformat() if customer and customer.customer_since else None,
                    'previousDisputes': customer.previous_disputes if customer else 0
                },
                'disputeReason': dispute.dispute_reason,
                'disputeDescription': dispute.dispute_description,
                'riskScore': dispute.risk_score,
                'aiRecommendation': dispute.ai_recommendation,
                'aiConfidence': dispute.ai_confidence,
                'aiAnalysis': dispute.ai_analysis,
                'status': dispute.status,
                'priority': dispute.priority,
                'createdAt': dispute.created_at.isoformat() if dispute.created_at else None,
                'updatedAt': dispute.updated_at.isoformat() if dispute.updated_at else None
            }
            disputes_list.append(dispute_dict)
        
        return jsonify({
            'disputes': disputes_list,
            'total': len(disputes_list),
            'category': category
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/disputes/by-subcategory/<subcategory>', methods=['GET'])
def get_disputes_by_subcategory(subcategory):
    """Get disputes by subcategory (1A_Card_Fraud, 2B_Technical_Processing, etc.)"""
    try:
        disputes = DisputeCase.query.filter_by(subcategory=subcategory).all()
        
        disputes_list = []
        for dispute in disputes:
            customer = Customer.query.get(dispute.customer_id)
            dispute_dict = {
                'id': dispute.id,
                'caseNumber': dispute.case_number,
                'category': dispute.category,
                'subcategory': dispute.subcategory,
                'reasonCode': dispute.reason_code,
                'cardNetwork': dispute.card_network,
                'transaction': {
                    'id': dispute.transaction_id,
                    'amount': dispute.amount,
                    'currency': dispute.currency,
                    'merchantName': dispute.merchant_name,
                    'merchantCategory': dispute.merchant_category,
                    'transactionDate': dispute.transaction_date.isoformat() if dispute.transaction_date else None,
                    'location': dispute.location,
                    'cardLast4': dispute.card_last4
                },
                'customer': {
                    'id': dispute.customer_id,
                    'name': customer.name if customer else 'Unknown',
                    'email': customer.email if customer else 'Unknown',
                    'phone': customer.phone if customer else 'Unknown',
                    'accountType': customer.account_type if customer else 'Unknown',
                    'creditScore': customer.credit_score if customer else 0,
                    'customerSince': customer.customer_since.isoformat() if customer and customer.customer_since else None,
                    'previousDisputes': customer.previous_disputes if customer else 0
                },
                'disputeReason': dispute.dispute_reason,
                'disputeDescription': dispute.dispute_description,
                'riskScore': dispute.risk_score,
                'aiRecommendation': dispute.ai_recommendation,
                'aiConfidence': dispute.ai_confidence,
                'aiAnalysis': dispute.ai_analysis,
                'status': dispute.status,
                'priority': dispute.priority,
                'createdAt': dispute.created_at.isoformat() if dispute.created_at else None,
                'updatedAt': dispute.updated_at.isoformat() if dispute.updated_at else None
            }
            disputes_list.append(dispute_dict)
        
        return jsonify({
            'disputes': disputes_list,
            'total': len(disputes_list),
            'subcategory': subcategory
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/categories/summary', methods=['GET'])
def get_category_summary():
    """Get summary statistics by category and subcategory"""
    try:
        # Category breakdown
        categories = {}
        for category in ['FRAUD_UNAUTHORIZED', 'PROCESSING_ISSUES', 'MERCHANT_MERCHANDISE']:
            count = DisputeCase.query.filter_by(category=category).count()
            high_risk_count = DisputeCase.query.filter_by(category=category).filter(DisputeCase.risk_score >= 70).count()
            categories[category] = {
                'total': count,
                'high_risk': high_risk_count,
                'risk_percentage': round((high_risk_count / count * 100) if count > 0 else 0, 1)
            }
        
        # Subcategory breakdown
        subcategories = {}
        subcategory_list = [
            '1A_Card_Fraud', '1B_Account_Compromise',
            '2A_Authorization_Failures', '2B_Technical_Processing', '2C_Refund_Processing',
            '3A_Product_Service', '3B_Cancellation_Returns', '3C_Subscription_Recurring',
            '3D_Merchant_Practices', '3E_Other_Miscellaneous'
        ]
        
        for subcategory in subcategory_list:
            count = DisputeCase.query.filter_by(subcategory=subcategory).count()
            avg_risk = db.session.query(db.func.avg(DisputeCase.risk_score)).filter_by(subcategory=subcategory).scalar()
            subcategories[subcategory] = {
                'total': count,
                'avg_risk_score': round(avg_risk, 1) if avg_risk else 0
            }
        
        # Priority breakdown
        priorities = {}
        for priority in ['low', 'medium', 'high', 'critical']:
            count = DisputeCase.query.filter_by(priority=priority).count()
            priorities[priority] = count
        
        # Status breakdown
        statuses = {}
        for status in ['pending', 'analyzing', 'review', 'completed']:
            count = DisputeCase.query.filter_by(status=status).count()
            statuses[status] = count
            
        # AI recommendation breakdown
        recommendations = {}
        for rec in ['approve', 'reject', 'review']:
            count = DisputeCase.query.filter_by(ai_recommendation=rec).count()
            recommendations[rec] = count
        
        return jsonify({
            'categories': categories,
            'subcategories': subcategories,
            'priorities': priorities,
            'statuses': statuses,
            'ai_recommendations': recommendations,
            'total_cases': DisputeCase.query.count()
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/disputes/reason-code/<reason_code>', methods=['GET'])
def get_disputes_by_reason_code(reason_code):
    """Get disputes by specific reason code"""
    try:
        disputes = DisputeCase.query.filter_by(reason_code=reason_code).all()
        
        disputes_list = []
        for dispute in disputes:
            customer = Customer.query.get(dispute.customer_id)
            dispute_dict = {
                'id': dispute.id,
                'caseNumber': dispute.case_number,
                'category': dispute.category,
                'subcategory': dispute.subcategory,
                'reasonCode': dispute.reason_code,
                'cardNetwork': dispute.card_network,
                'amount': dispute.amount,
                'merchantName': dispute.merchant_name,
                'disputeReason': dispute.dispute_reason,
                'riskScore': dispute.risk_score,
                'aiRecommendation': dispute.ai_recommendation,
                'status': dispute.status,
                'priority': dispute.priority
            }
            disputes_list.append(dispute_dict)
        
        return jsonify({
            'disputes': disputes_list,
            'total': len(disputes_list),
            'reason_code': reason_code
        })
        
    except Exception as e:
        return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
    
    app.run(debug=True, host='0.0.0.0', port=5001)
